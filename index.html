<!DOCTYPE html>
<html>
<head>
	<title>0831</title>
</head>

<style>
	body{
		margin: 0;
		overflow: hidden;
	}
</style>
<body>
	<div id="container"></div>
</body>

<script type="vsh" id="vertexShader">

	varying vec3 pos;
	varying vec2 vUv;

	void main(){
		vUv = uv;
		pos = position;

		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
	}
</script>

<script type="fsh" id="fragmentShader">

	varying vec2 vUv;
	uniform float time;
	uniform float qtime;
	uniform float utime;
	uniform float an;
	uniform float speed;
	uniform vec2 resolution;

	const float PI=3.14159265358979323846;
	// float speed=time*0.2975;
	float r = .1;
	// float qtime = sin (time)*.4;

	float Power =6.0;

	float marched = 0.0;
	float scale = .0;
	float min_distance = 1.0;
	float max_distance = 3.2;
	float glitter = 11.2;
	// float utime = time / 2.0;
	// float an= sin(utime)*3.14157;
	float h=0.7;

	vec2 rotate(vec2 k,float t)
	{
	return vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);
	}
	
	float sphere( vec3 pos){
		vec3 z = pos;
		float dr = 2.0;
		float r = 0.0;
		for (int i = 0; i < 10 ; i++) {
			r = length(z);
			if (r>2.0) break;

			// convert to polar coordinates
			float theta = acos( z.z/r );
			float phi = atan( z.y,z.x );
			dr =  pow( r, Power-1.0)*Power*dr + 1.0;

			// scale and rotate the point
			float zr = pow( r,Power);
			theta = theta*Power;
			phi = phi*Power;

			// convert back to cartesian coordinates
			z = (vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta))*zr);
			z+=pos;							
		}

		return 0.5*log(r)*r/dr;
	}
	
	float rm(vec3 origin, vec3 ray) {
		float distance_marched = min_distance;

			for (int i=0; i<150; i++) {		
			float step_distance = sphere(origin + ray*distance_marched);
				if (abs(step_distance) < 0.003 ) {
				return distance_marched/(max_distance-min_distance);
												 }
			distance_marched += step_distance;
			marched = distance_marched;
				if (distance_marched > max_distance) {
				return -1.0;
													 }
									  }		
		return -1.0;
	}

	vec3 render(vec2 q) {
		vec3 eye = vec3(0.0,.2, -3.0 + qtime/ 2.0 );
		vec3 screen = vec3(q,1.0);
		vec3 ray = normalize(screen - eye);
		// ray.yz=rotate(ray.yz,PI*0.5*sin(PI*qtime*0.125));		// rotation x
		// ray.zx=rotate(ray.zx,-PI*qtime*0.25);				// rotation y
		// ray.xy=rotate(ray.xy,speed*PI*0.8);					// rotation z

		// eye.yz=rotate(eye.yz,PI*0.5*sin(PI*qtime*0.125));		// rotation x
		// eye.zx=rotate(eye.zx,-PI*qtime*0.25);				// rotation y
		// eye.xy=rotate(eye.xy,speed*PI*0.8);					// rotation z
		
		float s = rm(eye, ray);
		vec3 col;
			if (s == -1.0) {
			col =  vec3(0.0);
						   } else {

									col = vec3(s-.8*.8+0.4*q.y *q.x)*marched/3.76;
									col.rg *= marched*.6;
								  }

		return col;
	}

	void main() {
		float qtime = sin (time)*.4;

		vec2 q =  (vUv.xy*4.0)-2.0 ;

		vec3 col = render(q);
		q.x=col.x;
		q.y=col.y;	
		gl_FragColor = vec4(col,1.0); 	
	}
</script>

<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FlyControls.js"></script>
<script src="setup.js"></script>
</html>