<!DOCTYPE html>
<html>
<head>
	<title>0831</title>
</head>

<style>
	body{
		margin: 0;
		overflow: hidden;
	}
</style>
<body>
	<div id="container"></div>
</body>

<script type="vsh" id="genericVertex">
	varying vec2 vUv;
	varying vec3 pos;
	varying vec3 vNormal;

	void main()	{
		vUv = uv;
		pos = position;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}
</script>

<script type="fsh" id="lavalampFragment">
	uniform sampler2D texture;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;
	varying vec3 pos;

	// Description : Array and textureless GLSL 3D simplex noise function.
	//      Author : Ian McEwan, Ashima Arts.
	//  Maintainer : ijm
	//     Lastmod : 20110409 (stegu)
	//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
	//               Distributed under the MIT License. See LICENSE file.
	//

	vec4 permute( vec4 x ) {

		return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

	}

	vec4 taylorInvSqrt( vec4 r ) {

		return 1.79284291400159 - 0.85373472095314 * r;

	}

	float snoise( vec3 v ) {

		const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
		const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

		// First corner

		vec3 i  = floor( v + dot( v, C.yyy ) );
		vec3 x0 = v - i + dot( i, C.xxx );

		// Other corners

		vec3 g = step( x0.yzx, x0.xyz );
		vec3 l = 1.0 - g;
		vec3 i1 = min( g.xyz, l.zxy );
		vec3 i2 = max( g.xyz, l.zxy );

		vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		vec3 x3 = x0 - 1. + 3.0 * C.xxx;

		// Permutations

		i = mod( i, 289.0 );
		vec4 p = permute( permute( permute(
				 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
			   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
			   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

		// Gradients
		// ( N*N points uniformly over a square, mapped onto an octahedron.)

		float n_ = 1.0 / 7.0; // N=7

		vec3 ns = n_ * D.wyz - D.xzx;

		vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

		vec4 x_ = floor( j * ns.z );
		vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

		vec4 x = x_ *ns.x + ns.yyyy;
		vec4 y = y_ *ns.x + ns.yyyy;
		vec4 h = 1.0 - abs( x ) - abs( y );

		vec4 b0 = vec4( x.xy, y.xy );
		vec4 b1 = vec4( x.zw, y.zw );


		vec4 s0 = floor( b0 ) * 2.0 + 1.0;
		vec4 s1 = floor( b1 ) * 2.0 + 1.0;
		vec4 sh = -step( h, vec4( 0.0 ) );

		vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
		vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

		vec3 p0 = vec3( a0.xy, h.x );
		vec3 p1 = vec3( a0.zw, h.y );
		vec3 p2 = vec3( a1.xy, h.z );
		vec3 p3 = vec3( a1.zw, h.w );

		// Normalise gradients

		vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;

		// Mix final noise value

		vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
		m = m * m;
		return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
									  dot( p2, x2 ), dot( p3, x3 ) ) );

	}

	float surface3( vec3 coord ) {

		float n = 0.0;

		n += 1.0 * abs( snoise( coord ) );
		n += 0.5 * abs( snoise( coord * 2.0 ) );
		n += 0.25 * abs( snoise( coord * 4.0 ) );
		n += 0.125 * abs( snoise( coord * 8.0 ) );

		return n;

	}

	void main(){
		vec3 coord = vec3( vUv, -time*speed );
		float n = surface3( coord );

		vec4 color = texture2D(texture, vUv + n*n);

		// gl_FragColor = vec4(vec3(n), 1.0 );
		// gl_FragColor = fragColor;
		gl_FragColor = vec4(color.rgb, .9);
	}
</script>

<script type="fsh" id="marblingFragment">
	uniform float time;
	uniform float speed;

	varying vec2 vUv;
	varying vec3 pos;

	float random (in vec2 st) { 
	    return fract(sin(dot(st.xy,
	                         vec2(12.9898,78.233)))* 
	        43758.5453123);
	}

	// Based on Morgan McGuire @morgan3d
	// https://www.shadertoy.com/view/4dS3Wd
	float noise (in vec2 st) {
	    vec2 i = floor(st);
	    vec2 f = fract(st);

	    // Four corners in 2D of a tile
	    float a = random(i);
	    float b = random(i + vec2(1.0, 0.0));
	    float c = random(i + vec2(0.0, 1.0));
	    float d = random(i + vec2(1.0, 1.0));

	    vec2 u = f * f * (3.0 - 2.0 * f);

	    return mix(a, b, u.x) + 
	            (c - a)* u.y * (1.0 - u.x) + 
	            (d - b) * u.x * u.y;
	}

	#define OCTAVES 2
	float fbm ( vec2 st) {
	    // Initial values
	    float value = 0.0;
	    float amplitud = .5;
	    float frequency = 0.;
	    //
	    // Loop of octaves
	    for (int i = 0; i < OCTAVES; i++) {
	        value += amplitud * noise(st+time*speed);
	        st *= 2.1;
	        amplitud *= .65;
	    }
	    return value;
	}

	// float pattern( in vec2 p ){
	// 	vec2 domainModifier = vec2( fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)) ); //using fbm, modify the domain (p)
	// 	return fbm(p + 4.0*domainModifier);
	// }

	// float pattern( vec2 p ){
	// 	vec2 domainModifier = vec2( fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)) ); //modify domain of the domainmodifier...
	// 	vec2 domainModifier2 = vec2( fbm(p + 4.0*domainModifier + vec2(1.7, 9.2)), fbm(p + 4.0*domainModifier + vec2(8.3, 2.8)));
	// 	return fbm(p + 4.0*domainModifier2);
	// }

	float pattern( in vec2 p )
	  {
	      vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),
	                     fbm( p + vec2(5.2,1.3) ) );

	      vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),
	                     fbm( p + 4.0*q + vec2(8.3,2.8) ) );

	      return fbm( p + 4.0*r );
	  }

	void main(){
		vec2 q; 
		vec2 r;
		vec2 j = vec2(0., 1.);
		float p = pattern(pos.xy);

		gl_FragColor = vec4(p, p, p, 1.);
	}

</script>

<script type="fsh" id="wormholeFragment">
	uniform vec2 resolution;
	uniform float time;
	void main()	{
		vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
		float a = time*40.0;
		float d,e,f,g=1.0/40.0,h,i,r,q;
		e=400.0*(p.x*0.5+0.5);
		f=400.0*(p.y*0.5+0.5);
		i=200.0+sin(e*g+a/150.0)*20.0;
		d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
		r=sqrt(pow(abs(i-e),2.0)+pow(abs(d-f),2.0));
		q=f/r;
		e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
		d=sin(e*g)*176.0+sin(e*g)*164.0+r;
		h=((f+d)+a/2.0)*g;
		i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
		h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
		h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
		i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
		i=mod(i/5.6,256.0)/64.0;
		if(i<0.0) i+=4.0;
		if(i>=2.0) i=4.0-i;
		d=r/350.0;
		d+=sin(d*d*8.0)*0.52;
		f=(sin(a*g)+1.0)/2.0;
		gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
	}

</script>

<script type="fsh" id="stepFragment">
	uniform vec2 resolution;
	uniform float opacity;

	void main(){
		vec2 st = gl_FragCoord.xy/resolution.xy;
		float pct = 0.;
		pct = step(distance(st, vec2(.5)), .5);
		gl_FragColor = vec4(vec3(pct), opacity);
	}
</script>

<script type="x-shader/x-vertex" id="tendrilsVertex">
//get a color value from texture based on uv coordinates
//use color value to manipulate vertex position
//repeat for added randomness 
//pass the extracted color value into fragment shader

	uniform float time;
	uniform sampler2D tPerlin;
	uniform float speed;
	uniform float pointSize;

	varying vec2 vUv;

	void main(){
		vUv = uv; //get uv coordinate on texture
		vec4 color = texture2D(tPerlin, uv); //get color based on uv coord [0, 1]
		vec4 color2 = texture2D(tPerlin, vec2(color.r, color.b) + time*speed);

		gl_PointSize = pointSize;

		gl_Position = projectionMatrix * modelViewMatrix * vec4(position + color2.rgb, 1.);
	}
</script>

<script type="fsh" id="tendrilsFragment">
	uniform sampler2D texture;
	uniform float opacity;
	uniform float time;
	uniform float speed;

	varying vec3 vNormal;
	varying vec2 vUv;

	void main(){
		vec4 color = texture2D(texture, vUv+time*speed);
		gl_FragColor = vec4(color.rgb, opacity);
	}
</script>

<script type="fsh" id="refractionFragment">
	uniform sampler2D texture;
	uniform float time;

	varying vec3 vNormal;
	varying vec2 vUv;

	// vec4 getNoise( vec2 uv ) {
	// 	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
	// 	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
	// 	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
	// 	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
	// 	vec4 noise = texture2D( normalSampler, uv0 ) +
	// 		texture2D( normalSampler, uv1 ) +
	// 		texture2D( normalSampler, uv2 ) +
	// 		texture2D( normalSampler, uv3 );
	// 	return noise * 0.5 - 1.0;
	// }

	void main(){
		vec2 uv0 = ( vUv / 103.0 ) + vec2(time / 17.0, time / 29.0);
		vec2 uv1 = vUv / 107.0-vec2( time / -19.0, time / 31.0 );
		vec2 uv2 = vUv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
		vec2 uv3 = vUv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
		vec4 color = texture2D(texture, vUv+((vNormal.xy+vec2(1.))/2.));
		gl_FragColor = vec4(color.rgb, 1.);
	}
</script>

<script type="fsh" id="kaleidoFragment">
	uniform sampler2D texture;
	uniform float sides;
	uniform float angle;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;

	void main() {

		vec2 p = vUv - 0.5;
		float r = length(p);
		float a = atan(p.y, p.x) + angle/5.;
		float tau = 2. * 3.1416 ;
		a = mod(a, tau/sides);
		a = abs(a - tau/sides/2.) ;
		p = r * vec2(cos(a), sin(a));
		vec4 color = texture2D(texture, p + 0.5 + time * speed);
		gl_FragColor = color;

	}
</script>

<script type="fsh" id="technicolorFragment">
	uniform float time;
	uniform float speed;

	float rand(float n){return fract(sin(n) * 43758.5453123);}

	void main() {
		float delta = time*speed;
		float r = (sin(rand(delta))+1.)/2.;
		float g = (cos(rand(delta))+1.)/2.;
		float b = (tan(rand(delta))+1.)/2.;
		// gl_FragColor = vec4(1., 1., 0., smoothstep(0., 1., sin(delta)));
		gl_FragColor = vec4(1., 1., 0., 1.);
		// float c = step(0.,sin(time));
		// gl_FragColor = vec4(c);
	}
</script>

<script type="fsh" id="glitchFragment">
	uniform sampler2D tDiffuse;
	uniform sampler2D tDisp;
	uniform float amount;
	uniform float angle;
	uniform float seed;
	// uniform float seed_x;
	// uniform float seed_y;
	// uniform float distortion_x;
	// uniform float distortion_y;
	uniform float col_s;
	uniform float time;
	uniform float speed;
	varying vec2 vUv;

	float rand(vec2 co){
		return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
	}

	void main() {
		float distortion_x = sin(time*speed);
		float distortion_y = sin(time*speed);

		float seed = tan(time*speed);
		float seed_x = cos(time*speed);
		float seed_y = sin(time*speed);

		vec2 p = vUv;
		float xs = floor(gl_FragCoord.x / 0.5);
		float ys = floor(gl_FragCoord.y / 0.5);
		vec4 normal = texture2D (tDisp, p*seed*seed);

		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {
			if(seed_x>0.){
				p.y = 1. - (p.y + distortion_y);
			}
			else {
				p.y = distortion_y;
			}
		}
		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {
			if(seed_y>0.){
				p.x=distortion_x;
			}
			else {
				p.x = 1. - (p.x + distortion_x);
			}
		}
		p.x+=normal.x*seed_x*(seed/5.);
		p.y+=normal.y*seed_y*(seed/5.);
		
		vec2 offset = amount * vec2( cos(angle), sin(angle));
		vec4 cr = texture2D(tDiffuse, p + offset);
		vec4 cga = texture2D(tDiffuse, p);
		vec4 cb = texture2D(tDiffuse, p - offset);
		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);

		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);
		gl_FragColor = gl_FragColor+ snow;
	}
</script>

<script type="fsh" id="videoFragment">
	uniform sampler2D tVideo;

	varying vec2 vUv;

	void main() {
		vec4 color = texture2D(tVideo, vec2(vUv.x, vUv.y));
		gl_FragColor = vec4(color.rgb, 1.);
	}
</script>

<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FlyControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrthographicTrackballControls.js"></script>
<script src="js/OpenBoxBufferGeometry.js"></script>
<script src="js/data.js"></script>
<script src="js/Heart.js"></script>
<script src="setup.js"></script>
</html>