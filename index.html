<!DOCTYPE html>
<html>
<link rel="shortcut icon" type="image/png" href="assets/heart.png" sizes="16x16"/>
<link rel="stylesheet" type="text/css" href="assets/fonts/circular-web/stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="assets/fonts/proxima-nova-web/stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="css/style.css"/>
<head>
	<title>Heart</title>
</head>

<style>
	body{
		margin: 0;
		overflow: hidden;
	}
</style>
<body>
	<div id="title">
		<div class="wrapper">
			<div id="hearts">
				<div class="heart heart-1">
					<div>
						<img src="assets/heart-dark.png"/>
					</div>
				</div>

				<div class="heart heart-2">
					<img src="assets/heart-dark.png"/>
				</div>

				<div class="heart heart-3">
					<img src="assets/heart-dark.png"/>
				</div>
			</div>

			<h1>HEART HEART HEART</h1>

			<div class="description">
				<h2>A compilation of things about our mom.</h2>
				<h2>08/31: Happy Birthday.</h2>
			</div>
		</div>
	</div>
	<div id="nav">
		<div class="flex-container">
			<div class="flex-item active"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
		</div>

		<div class="flex-container">
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
		</div>

		<div class="flex-container">
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
		</div>

		<div class="flex-container">
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
			<div class="flex-item"></div>
		</div>
	</div>
	<div id="ui" class="hide">
		<div id="quote">
			<h1>Two eggs, over easy. Coffee, black.</h1>
			<div id="close">
				<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
						 viewBox="0 0 500 500" style="enable-background:new 0 0 500 500;" xml:space="preserve">
					<style type="text/css">
						.st0{fill:#aaaaaa;}
					</style>
					<g id="XMLID_4_">
						<path id="XMLID_5_" class="st0" d="M114.3,198.8c-6.7,70.3-17.4,161.1-32.8,221.1L5,389.2C21.5,333.8,35.3,258.3,41,185
							L114.3,198.8z M218,159.3v230.4c0,25.1,3.1,28.2,25.7,28.2h59c23.1,0,27.2-14.9,30.8-90.8c16.9,12.8,49.8,26.2,69.8,31.3
							c-7.7,97.5-27.2,128.8-93.9,128.8h-75.9c-73.4,0-93.4-23.6-93.4-97.5V159.3H218z M204.6,12.6C250.8,40.3,318,83.9,349.8,115.7
							l-55.4,59c-28.2-31.8-92.9-79.5-140.6-110.8L204.6,12.6z M429.8,166.5c28.7,61.1,54.4,138,65.2,191.4l-75.9,31.8
							c-7.7-52.3-32.8-133.9-59-194.4L429.8,166.5z"/>
					</g>
					</svg>
			</div>
		</div>
	</div>
	<div id="container"></div>
	<!-- <div id="instructions">
		Navigate with panel!
	</div> -->
</body>

<script type="vsh" id="genericVertex">
	varying vec2 vUv;
	varying vec3 pos;
	varying vec3 vNormal;

	void main()	{
		vUv = uv;
		pos = position;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}
</script>

<script type="fsh" id="lavalampFragment">
	uniform sampler2D texture;
	uniform float time;
	uniform float speed;
	uniform float octaveNum;

	varying vec2 vUv;
	varying vec3 pos;

	// Description : Array and textureless GLSL 3D simplex noise function.
	//      Author : Ian McEwan, Ashima Arts.
	//  Maintainer : ijm
	//     Lastmod : 20110409 (stegu)
	//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
	//               Distributed under the MIT License. See LICENSE file.
	//

	vec4 permute( vec4 x ) {

		return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

	}

	vec4 taylorInvSqrt( vec4 r ) {

		return 1.79284291400159 - 0.85373472095314 * r;

	}

	float snoise( vec3 v ) {

		const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
		const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

		// First corner

		vec3 i  = floor( v + dot( v, C.yyy ) );
		vec3 x0 = v - i + dot( i, C.xxx );

		// Other corners

		vec3 g = step( x0.yzx, x0.xyz );
		vec3 l = 1.0 - g;
		vec3 i1 = min( g.xyz, l.zxy );
		vec3 i2 = max( g.xyz, l.zxy );

		vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		vec3 x3 = x0 - 1. + 3.0 * C.xxx;

		// Permutations

		i = mod( i, 289.0 );
		vec4 p = permute( permute( permute(
				 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
			   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
			   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

		// Gradients
		// ( N*N points uniformly over a square, mapped onto an octahedron.)

		float n_ = 1.0 / 7.0; // N=7

		vec3 ns = n_ * D.wyz - D.xzx;

		vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

		vec4 x_ = floor( j * ns.z );
		vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

		vec4 x = x_ *ns.x + ns.yyyy;
		vec4 y = y_ *ns.x + ns.yyyy;
		vec4 h = 1.0 - abs( x ) - abs( y );

		vec4 b0 = vec4( x.xy, y.xy );
		vec4 b1 = vec4( x.zw, y.zw );


		vec4 s0 = floor( b0 ) * 2.0 + 1.0;
		vec4 s1 = floor( b1 ) * 2.0 + 1.0;
		vec4 sh = -step( h, vec4( 0.0 ) );

		vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
		vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

		vec3 p0 = vec3( a0.xy, h.x );
		vec3 p1 = vec3( a0.zw, h.y );
		vec3 p2 = vec3( a1.xy, h.z );
		vec3 p3 = vec3( a1.zw, h.w );

		// Normalise gradients

		vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
		p0 *= norm.x;
		p1 *= norm.y;
		p2 *= norm.z;
		p3 *= norm.w;

		// Mix final noise value

		vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
		m = m * m;
		return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
									  dot( p2, x2 ), dot( p3, x3 ) ) );

	}

	float surface3( vec3 coord ) {

		float n = 0.0;

		n += 1.0 * abs( snoise( coord ) );
		n += 0.5 * abs( snoise( coord * 2.0 ) );
		n += 0.25 * abs( snoise( coord * 4.0 ) );
		n += 0.125 * abs( snoise( coord * 8.0 ) );

		return n;

	}

	void main(){
		vec3 coord = vec3( vUv, -time*speed );
		float n = surface3( coord );

		vec4 color = texture2D(texture, vUv + n*n);

		// gl_FragColor = vec4(vec3(n), 1.0 );
		// gl_FragColor = fragColor;
		gl_FragColor = vec4(color.rgb, .9);
	}
</script>

<script type="fsh" id="marblingFragment">
	uniform float time;
	uniform float speed;

	varying vec2 vUv;
	varying vec3 pos;

	float random (in vec2 st) { 
	    return fract(sin(dot(st.xy,
	                         vec2(12.9898,78.233)))* 
	        43758.5453123);
	}

	// Based on Morgan McGuire @morgan3d
	// https://www.shadertoy.com/view/4dS3Wd
	float noise (in vec2 st) {
	    vec2 i = floor(st);
	    vec2 f = fract(st);

	    // Four corners in 2D of a tile
	    float a = random(i);
	    float b = random(i + vec2(1.0, 0.0));
	    float c = random(i + vec2(0.0, 1.0));
	    float d = random(i + vec2(1.0, 1.0));

	    vec2 u = f * f * (3.0 - 2.0 * f);

	    return mix(a, b, u.x) + 
	            (c - a)* u.y * (1.0 - u.x) + 
	            (d - b) * u.x * u.y;
	}

	#define OCTAVES 2
	float fbm ( vec2 st) {
	    // Initial values
	    float value = 0.0;
	    float amplitud = .5;
	    float frequency = 0.;
	    //
	    // Loop of octaves
	    for (int i = 0; i < OCTAVES; i++) {
	        value += amplitud * noise(st+time*speed);
	        st *= 2.1;
	        amplitud *= .65;
	    }
	    return value;
	}

	// float pattern( in vec2 p ){
	// 	vec2 domainModifier = vec2( fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)) ); //using fbm, modify the domain (p)
	// 	return fbm(p + 4.0*domainModifier);
	// }

	// float pattern( vec2 p ){
	// 	vec2 domainModifier = vec2( fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)) ); //modify domain of the domainmodifier...
	// 	vec2 domainModifier2 = vec2( fbm(p + 4.0*domainModifier + vec2(1.7, 9.2)), fbm(p + 4.0*domainModifier + vec2(8.3, 2.8)));
	// 	return fbm(p + 4.0*domainModifier2);
	// }

	float pattern( in vec2 p )
	  {
	      vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),
	                     fbm( p + vec2(5.2,1.3) ) );

	      vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),
	                     fbm( p + 4.0*q + vec2(8.3,2.8) ) );

	      return fbm( p + 4.0*r );
	  }

	void main(){
		vec2 q; 
		vec2 r;
		vec2 j = vec2(0., 1.);
		float p = pattern(pos.xy);

		gl_FragColor = vec4(p, p, p, 1.);
	}

</script>

<script type="fsh" id="wormholeFragment">
	uniform vec2 resolution;
	uniform float time;
	void main()	{
		vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
		float a = time*40.0;
		float d,e,f,g=1.0/40.0,h,i,r,q;
		e=400.0*(p.x*0.5+0.5);
		f=400.0*(p.y*0.5+0.5);
		i=200.0+sin(e*g+a/150.0)*20.0;
		d=200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;
		r=sqrt(pow(abs(i-e),2.0)+pow(abs(d-f),2.0));
		q=f/r;
		e=(r*cos(q))-a/2.0;f=(r*sin(q))-a/2.0;
		d=sin(e*g)*176.0+sin(e*g)*164.0+r;
		h=((f+d)+a/2.0)*g;
		i=cos(h+r*p.x/1.3)*(e+e+a)+cos(q*g*6.0)*(r+h/3.0);
		h=sin(f*g)*144.0-sin(e*g)*212.0*p.x;
		h=(h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;
		i+=cos(h*2.3*sin(a/350.0-q))*184.0*sin(q-(r*4.3+a/12.0)*g)+tan(r*g+h)*184.0*cos(r*g+h);
		i=mod(i/5.6,256.0)/64.0;
		if(i<0.0) i+=4.0;
		if(i>=2.0) i=4.0-i;
		d=r/350.0;
		d+=sin(d*d*8.0)*0.52;
		f=(sin(a*g)+1.0)/2.0;
		gl_FragColor=vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);
	}

</script>

<script type="fsh" id="stepFragment">
	uniform vec2 resolution;
	uniform float opacity;

	void main(){
		vec2 st = gl_FragCoord.xy/resolution.xy;
		float pct = 0.;
		pct = step(distance(st, vec2(.5)), .5);
		gl_FragColor = vec4(vec3(pct), opacity);
	}
</script>

<script type="x-shader/x-vertex" id="tendrilsVertex">
//get a color value from texture based on uv coordinates
//use color value to manipulate vertex position
//repeat for added randomness 
//pass the extracted color value into fragment shader

	uniform float time;
	uniform sampler2D tPerlin;
	uniform float speed;
	uniform float pointSize;

	varying vec2 vUv;

	void main(){
		vUv = uv; //get uv coordinate on texture
		vec4 color = texture2D(tPerlin, uv); //get color based on uv coord [0, 1]
		vec4 color2 = texture2D(tPerlin, vec2(color.r, color.b) + time*speed);

		gl_PointSize = pointSize;

		gl_Position = projectionMatrix * modelViewMatrix * vec4(position + 2.*color2.rgb, 1.);

	}
</script>

<script type="fsh" id="tendrilsFragment">
	uniform sampler2D texture;
	uniform float opacity;
	uniform float time;
	uniform float speed;

	varying vec3 vNormal;
	varying vec2 vUv;

	void main(){
		vec4 color = texture2D(texture, vUv+time*speed);
		gl_FragColor = vec4(color.rgb, opacity);
	}
</script>

<script type="fsh" id="refractionFragment">
	uniform sampler2D texture;
	uniform float time;

	varying vec3 vNormal;
	varying vec2 vUv;

	// vec4 getNoise( vec2 uv ) {
	// 	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
	// 	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
	// 	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
	// 	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
	// 	vec4 noise = texture2D( normalSampler, uv0 ) +
	// 		texture2D( normalSampler, uv1 ) +
	// 		texture2D( normalSampler, uv2 ) +
	// 		texture2D( normalSampler, uv3 );
	// 	return noise * 0.5 - 1.0;
	// }

	void main(){
		vec2 uv0 = ( vUv / 103.0 ) + vec2(time / 17.0, time / 29.0);
		vec2 uv1 = vUv / 107.0-vec2( time / -19.0, time / 31.0 );
		vec2 uv2 = vUv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
		vec2 uv3 = vUv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
		vec4 color = texture2D(texture, vUv+((vNormal.xy+vec2(1.))/2.));
		gl_FragColor = vec4(color.rgb, 1.);
	}
</script>

<script type="fsh" id="kaleidoFragment">
	uniform sampler2D texture;
	uniform float sides;
	uniform float angle;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;

	void main() {

		vec2 p = vUv - 0.5;
		float r = length(p);
		float a = atan(p.y, p.x) + angle/5.;
		float tau = 2. * 3.1416 ;
		a = mod(a, tau/sides);
		a = abs(a - tau/sides/2.) ;
		p = r * vec2(cos(a), sin(a));
		vec4 color = texture2D(texture, p + 0.5 + time * speed);
		gl_FragColor = color;

	}
</script>

<script type="fsh" id="technicolorFragment">
	uniform float time;
	uniform float speed;

	float rand(float n){return fract(sin(n) * 43758.5453123);}

	void main() {
		float delta = time*speed;
		float r = (sin(rand(delta))+1.)/2.;
		float g = (cos(rand(delta))+1.)/2.;
		float b = (tan(rand(delta))+1.)/2.;
		gl_FragColor = vec4(step(0.5, cos(delta)), smoothstep(0.5, 1., sin(delta)), smoothstep(0., 1., tan(delta)), 1.);
		// gl_FragColor = vec4(1., 1., 0., 1.);
		// float c = step(0.,sin(time));
		// gl_FragColor = vec4(c);
	}
</script>

<script type="fsh" id="glitchFragment">
	uniform sampler2D tDiffuse;
	uniform sampler2D tDisp;
	uniform float amount;
	uniform float angle;
	uniform float seed;
	// uniform float seed_x;
	// uniform float seed_y;
	// uniform float distortion_x;
	// uniform float distortion_y;
	uniform float col_s;
	uniform float time;
	uniform float speed;
	varying vec2 vUv;

	float rand(vec2 co){
		return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
	}

	void main() {
		float distortion_x = sin(time*speed);
		float distortion_y = sin(time*speed);

		float seed = tan(time*speed);
		float seed_x = cos(time*speed);
		float seed_y = sin(time*speed);

		vec2 p = vUv;
		float xs = floor(gl_FragCoord.x / 0.5);
		float ys = floor(gl_FragCoord.y / 0.5);
		vec4 normal = texture2D (tDisp, p*seed*seed);

		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {
			if(seed_x>0.){
				p.y = 1. - (p.y + distortion_y);
			}
			else {
				p.y = distortion_y;
			}
		}
		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {
			if(seed_y>0.){
				p.x=distortion_x;
			}
			else {
				p.x = 1. - (p.x + distortion_x);
			}
		}
		p.x+=normal.x*seed_x*(seed/5.);
		p.y+=normal.y*seed_y*(seed/5.);
		
		vec2 offset = amount * vec2( cos(angle), sin(angle));
		vec4 cr = texture2D(tDiffuse, p + offset);
		vec4 cga = texture2D(tDiffuse, p);
		vec4 cb = texture2D(tDiffuse, p - offset);
		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);

		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);
		gl_FragColor = gl_FragColor+ snow;
	}
</script>

<script type="fsh" id="videoFragment">
	uniform sampler2D tVideo;

	varying vec2 vUv;

	void main() {
		vec4 color = texture2D(tVideo, vec2(vUv.x, vUv.y));
		gl_FragColor = vec4(color.rgb, 1.);
	}
</script>

<script type="fsh" id="gradientFragment">
	uniform vec3 colorA;
	uniform vec3 colorB;
	uniform vec2 resolution;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;

	void main(){
		vec2 vUv2 = vUv + 2.5*abs(sin(time*speed));
		vec2 st = gl_FragCoord.xy/vUv2.xy;
		vec3 color = vec3(0.);

		vec3 pct = vec3(sin(3.14159*st.x))/2.;

		color = mix(colorA, colorB, pct);

		gl_FragColor = vec4(color, pct.x);
	}
</script>

<script type="fsh" id="ringFragment">
	uniform vec2 resolution;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;

	void main(){
		vec2 st = gl_FragCoord.xy/resolution.xy;
		vec3 color = vec3(0.);
		float d = 0.;

		st = st*2.-1.;

		// d = length(abs(st)-.5);
		d = length(abs(st));

		gl_FragColor = vec4(vec3( fract( d*abs(sin(time*speed))*16. ) ), .5);
	}
</script>

<script type="fsh" id="rainbowFragment">
	uniform vec2 resolution;
	uniform float time;
	uniform float speed;

	varying vec2 vUv;

	#define TWO_PI 6.28318530718

	//  Function from Iñigo Quiles 
	//  https://www.shadertoy.com/view/MsS3Wc
	vec3 hsb2rgb( in vec3 c ){
	    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
	                             6.0)-3.0)-1.0, 
	                     0.0, 
	                     1.0 );
	    rgb = rgb*rgb*(3.0-2.4*rgb);
	    return c.z * mix( vec3(1.0), rgb, c.y);
	}

	void main(){
	    vec2 st = gl_FragCoord.xy/resolution.xy;
	    vec3 color = vec3(0.0);

	    // Use polar coordinates instead of cartesian
	    vec2 toCenter = vec2(0.5)-st;
	    float angle = atan(toCenter.y,toCenter.x) + time*speed;
	    float radius = length(toCenter)*2.0;
	  
	    // Map the angle (-PI to PI) to the Hue (from 0 to 1)
	    // and the Saturation to the radius
	    color = hsb2rgb(vec3((angle/TWO_PI)+sin(time*speed),radius,1.0));

	    gl_FragColor = vec4(color,1.0);
	}
</script>

<script type="fsh" id="sepiaFragment">
	uniform float amount;
	uniform sampler2D tDiffuse;
	varying vec2 vUv;
	void main() {
		vec4 color = texture2D( tDiffuse, vUv );
		vec3 c = color.rgb;
		color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
		color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
		color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
		gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );

	}
</script>

<script type="fsh" id="crystalFragment">
	// Quasicrystal based on Matt Henderson's blog post:
	// http://blog.matthen.com/post/51566631087/quasicrystals-are-highly-structured-patterns-which	
	// click and drag the mouse for interactivity.
	// Left/Right: scale
	// Up/Down: number of waves

	// normalized mouse position. Default values

	uniform vec2 resolution;
	uniform float time;
	uniform float speed;

	void main()
	{		
		float speed = 2.0;
		float scale = 0.1;
		const int N_MAX = 20;
		// float n = 5.+ 5.*abs(sin(.25*time*speed));
		float n = 7.0;
		
		// click and drag left and right to adjust scale (left zooms out)
		// scale = 0.1 + (1.0-.5*sin(.05*time*speed));
		scale = 0.1 + (1.0 - .5 );
		
		const float pi = 3.1415926;
		
		// accumulate n waves
		float S = 0.0;
		for( int i=0; i < N_MAX; ++i){
		
			// allow for n+1 waves
			if( i >= (int(n)+1) )
				break;
			
			float theta = pi * float(i)/float(n);
				
			// center coordinates in viewport
			float x = gl_FragCoord.x - (resolution.x*0.5);
			float y = gl_FragCoord.y - (resolution.y*0.5);
			
			float wp = x*cos(theta) + y*sin(theta);
			float w = sin(wp*scale + 5.*time*speed);
			
			// fade out the final wave in proportion to n-floor(n)
			if( i == int(n) )
				w *= n-floor(n);		
			
			// accumulate 
			S += 3.0 * w / n;
		}
		
		// sin/cos hackery to get some colours
		gl_FragColor = vec4(sin(S-0.1)*.6,cos(S+.3)*.9,cos(S+.1)*1.1,1.0);
		
		// greyscale version:
		//fragColor = vec4(S,S,S,1.0);
	}
</script>

<script type="fsh" id="cellsFragment">
	// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )
	// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )
	// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8

	uniform float time;
	uniform vec2 resolution;
	uniform float tNoise;

	#define ANIMATE

	vec2 hash2( vec2 p )
	{
	    // procedural white noise	
		return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
	}

	vec2 dist(vec2 g, vec2 x) {
	    vec2 n = floor(x), f = fract(x),
	         o = hash2( n + g );
		#ifdef ANIMATE
	    o = .5 + .5*sin( time + 6.2831*o );
	    #endif	
	    return g + o - f;
	}

	vec4 voronoi( vec2 x )
	{
	    //----------------------------------
	    // first pass: regular voronoi
	    //----------------------------------
		vec2 mg, mr;

	    float md = 8., md2, md3;
	    for( int j=-1; j<=1; j++ )
	        for( int i=-1; i<=1; i++ ) {
	            vec2  g = vec2(i,j), 
	                  r = dist(g, x);
	            float d = dot(r,r);

	            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state
	        }

	    //----------------------------------
	    // second pass: distance to borders
	    //----------------------------------
	    md = 8.;
	    for( int j=-2; j<=2; j++ )
	        for( int i=-2; i<=2; i++ ) {
	            vec2 g = mg + vec2(i,j),       // around cell of closest
	                 r = dist(g, x);

	            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell
	                float d = dot( .5*(mr+r), normalize(r-mr) );
	                if ( d < md ) md3=md2, md2=md, md=d;
	                else if (d < md2 ) md3 = md2, md2=d;
	                else  if (d < md3 ) md3 = d;
	            }
	        }
	  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D
	    return vec4( md, md2, mr );            // 2 distances to border + seed pos
	}


	void main()
	{	
		vec2 p = gl_FragCoord.xy/resolution.xy;
	    // p /= resolution.x;

	    vec4 c = voronoi( 8.*p );
	    float d = c.x;              // original IQ's constant border width Voronoï 
	    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV
	                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )
	    // d = 2./(1./c.y+1./c.z);  // 3D
	    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );
	    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );
	    
		// isolines
	    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));
	    // borders	
	  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(time)) ) );
	    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(time) ) );

	    // feature points
		float dd = length( c.zw );
		col =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )
		      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);

		gl_FragColor = vec4(col,1.);
	}
</script>

<script type="fsh" id="wavesFragment">
	uniform vec2 resolution;
	uniform float time;

	void main() {
		vec4 fragColor = vec4(0.);
		vec2 uv = gl_FragCoord.xy / resolution.xy ;
		fragColor = vec4(uv,0.5+0.5*sin(time/4.0),1.0)
	      * sin(time/8.0)
	      - cos(gl_FragCoord.x * time / 17.3 + time / 8.0)
	      - sin(gl_FragCoord.y * time / 11.0 + time / 7.0)
	      + sin(gl_FragCoord.x / 2910.0 * gl_FragCoord.y / 2230.0
	        / ((sin(time/419.0
	          + sin(gl_FragCoord.x*0.2 + gl_FragCoord.y*0.14))+1.0)/2.0/8.0
	        )
	        + time/78.0 * sin(time/200.1)
	          * (1.0 + sin(time/473.0))*153.7
	      ) * sin(gl_FragCoord.x / 3.0 + cos(time/4.0)*5.0)
	      + cos(gl_FragCoord.y / 31.0
	        + sin(time/8.0+sin(time/40.0))
	        + sin(time*6.2+gl_FragCoord.x/(
	          (1.0+sin(time/16.0))*50.0
	        ))
	        + sin(time*4.3+gl_FragCoord.y/(
	          (1.0+sin(time/11.0))*23.0
	        ))
	      )
	    ;

	    gl_FragColor = fragColor;
	}
</script>

<script type="fsh" id="fbmFragment">	
	uniform vec2 resolution;
	uniform float time;

	//// COLORS ////
	const vec3 ORANGE = vec3(1.0, 0.6, 0.2);
	 
	const vec3 BLUE   = vec3(0.2, 0.6, 0.6);
	const vec3 BLACK  = vec3(0.1, 0.0, 0.1);

	///// MATHS /////
	const float PI = 3.14;

	vec2 maplinear ( in vec2 x, in vec2 a1, in vec2 a2, in vec2 b1, in vec2 b2 ) {
	    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	}

	///// NOISE /////
	float hash( float n ) {
	    return fract(sin(n)*43758.5453123);   
	}

	float noise( in vec2 x ){
	    vec2 p = floor(x);
	    vec2 f = fract(x);
	    f = f * f * (3.0 - 2.0 * f);
	    float n = p.x + p.y * 57.0;
	    return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
	}

	////// FBM ////// 
	mat2 m = mat2( 0.6, 0.6, -0.6, 0.8);
	float fbm(vec2 p){
	 
	    float f = 0.0;
	    f += 0.5000 * noise(p); p *= m * 2.02;
	    f += 0.2500 * noise(p); p *= m * 2.03;
	    f += 0.1250 * noise(p); p *= m * 2.01;
	    f += 0.0625 * noise(p); 
	    f /= 0.9375;
	    return f;
	}

	void main(){
	    vec4 fragColor = vec4(0.);
	    // pixel ratio  
		vec2 uv = gl_FragCoord.xy / resolution.xy;  
	    vec2 p = - 1. + 2. * uv;  
	    p.x *= resolution.x / resolution.y ;
	  	
	    // 2 Fbm origins
	    vec2  ctr  = vec2( 1.0, 0.0);
	    vec2  ctr2 = vec2(-1.0, 0.0);  
	    
	    // MOUSE
	    vec2 m = vec2(.5, .5);
	        
	    // domains
	    float rad  = sqrt(dot(p, p)); 
	    float r    = sqrt(dot(p + ctr, p + ctr)) + m.y; 
	    float r2   = sqrt(dot(p + ctr2, p + ctr2))+ m.y;  
	    float a = r * r2;
	                    
	    // distortions      
	    a *= fbm(m.x * p);
	    // with symmetry
	    //a *= fbm(m.x * sqrt(p*p));
	    a -= time * 0.3 ;

	    // colorize
	    vec3 col = BLACK;
	    float f = smoothstep(0.1, 0.9, fbm(vec2(a * 20.0, r * r2)));  
	    col =  mix( col, BLUE, f); 
	    f = smoothstep(0.4, 0.9, fbm(vec2(a * 2.0 , r * r2)));  
	    col =  mix( col, ORANGE, f );
	    f = smoothstep(0.3, 0.9, fbm(vec2(a * 50.0, r * r2)));  
	    col *=  1.8 - f ; 

	    fragColor = vec4(col, 1.);

	    gl_FragColor = fragColor;
	}
</script>

<script src="bower_components/tween.js/src/Tween.js"></script>
<script src="bower_components/three.js/build/three.js"></script>
<script src="bower_components/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FirstPersonControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/FlyControls.js"></script>
<script src="bower_components/three.js/examples/js/controls/OrthographicTrackballControls.js"></script>
<script src="js/FlatControls.js"></script>
<script src="js/quotes.js"></script>
<script src="js/data.js"></script>
<script src="js/heart.js"></script>
<script src="js/ui.js"></script>
<script src="setup.js"></script>
</html>